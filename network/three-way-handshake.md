# TCP三次握手和四次挥手

## 三次握手

### 过程

![三次握手](https://s3.ax1x.com/2021/01/21/s5PSw8.png)

#### **第一次握手**

建立连接时，客户端发送SYN报文，标志位SYN=1。

随机生成初始序列号ISN，作为序列号Seq Num = client_isn。ISN动态随机生成使得每个tcp session的字节序列号没有重叠。也为了增加安全性，为了避免被第三方猜测，从而被第三方伪造的RST报文Reset。伪造的报文要想成功，需要Seq Num 位于对方的合法接收窗口内， 而由于ISN是动态随机的，猜出对方接收窗口难度加大。

规定第一次握手不携带数据。如果第一次握手携带数据，先由服务端缓存下来等建立连接后再处理，这样会导致SYN FLOOD攻击。攻击者会用大量的携带数据的握手报文，让接收方被迫开辟大量的空间来缓存这些数据，从而耗尽内存，关闭服务。

客户端进入SYN_SENT状态，等待服务器确认。

#### 第二次握手

服务器收到SYN报文后，如果同意连接，则发出确认报文。告知客户端：客户端发送正常，服务端接收正常。

确认报文中的标志位 ACK=1, SYN=1, 确认序号Ack Num = client_isn + 1, 同时也要为自己初始化一个序列号 Seq Num= server_isn。这个报文也不能携带数据, 但是同样要消耗一个序号。

TCP服务器进程进入了SYN-RCVD状态。

#### 第三次握手

客户端收到确认报文后，再次向服务器确认，告知服务器：客户端接收正常，服务器发送正常。

确认报文的标志位ACK=1，序列号Seq Num = client_isn + 1, 确认序号Ack Num = server_isn + 1，

第三次握手时可以携带数据。因为伪造的第三方是无法接收到第二次握手的报文，能发出第三次握手报文的用户都是合法的。

TCP连接建立，客户端进入ESTABLISHED状态。当服务器收到客户端的确认后也进入ESTABLISHED状态，就可以正常处理携带的数据。此后双方就可以开始通信了。

### 原因

从建立连接的过程可以知道，三次握手是可以让双方确认彼此收发能力的最小次数。除此之外，三次握手还有其他原因：

1. **阻止重复历史连接的初始化**

   > *The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.*

   RFC 793指出，三次握手的主要原因是防止旧的重复连接初始化造成混乱。

   比如客户端发送一个Seq Num = 50的SYN报文1，由于网络阻塞，客户端又重新发送发送了一个Seq Num = 100的SYN报文2。一段时间后，服务器先收到了SYN报文1，并且返回Ack Num = 51的确认报文。客户端收到后，检查发现这个报文并不是自己期望的Ack Num = 101的报文，所以发送了RST报文来终止连接。一段时间后，服务器收到了SYN报文2，返回确认报文Ack Num = 101。客户端收到后再次确认，建立连接成功。

   所以在上面这个过程中，第三次握手让客户端可以判断当前连接是否是旧的重复连接，从而选择终止连接或成功建立连接。

   如果是两次握手，客户端就不能判断是否是重复连接。因为第二次握手时，服务器已经为连接分配资源，客户端只能选择建立连接, 而这个连接是没有任何用处的。这样会导致双方资源的浪费。

2. **同步双方初始序列号**

    TCP通过序列号维持可靠传输。通过序列号：接收方可以丢弃重复的包；接收方可以根据序号按序接收；可以标识发出的包中，有哪些被对方成功接收。客户端发送携带初始序列号的SYN报文，需要服务端返回ACK应答，表示客户端的初始序列号成功创建滑动窗口。反之，服务端的初始序列号同样需要客户端的确认。这样的两次来回，才能确认双方的初始序列号都可以同步。在这来回的四次中，服务端确认ACK，和服务端发送自己的初始序列号可以合并在一个报文中，因此就简化成了三次握手。

3. **避免资源浪费**

   如果只有两次握手，当客户端的SYN报文在网络中阻塞时，客户端没有收到来自服务器的ACK报文，就会重新发送SYN。一段时间后，当服务器接收到了SYN报文，由于没有第三次握手，服务器不清楚客户端是否收到了自己的确认报文，所以只能对每个SYN都建立一个连接。这样会导致服务器建立多个重复冗余的连接，造成资源浪费。

## 四次挥手

 ### 过程

![](https://s3.ax1x.com/2021/01/21/s5PkSs.png)

#### 第一次挥手

客户端发送FIN报文，标志位FIN=1，序列号为Seq Num为之前对方最后传过来的数据的最后一个字节的序号+1，假设Seq Num = u. 客户端停止发送数据，进入FIN-WAIT-1状态。

#### 第二次挥手

服务端收到FIN报文后，发出确认报文，标志位ACK=1，确认序号Ack Num = u + 1，假设自己的序列号Seq Num = v。

服务端进入CLOSE-WAIT状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态。即客户端已经没有数据要发送了，但是服务器若发送数据，或者有数据包还在网络中，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。

客户端收到服务器的确认请求后，进入FIN-WAIT-2状态，等待服务器发送FIN报文，期间继续接收服务器发送的数据包。

 #### 第三次挥手

一段时间后，服务器发送完最后的数据包，就向客户端发送FIN报文，标志位FIN=1, Ack Num = u+1, 由于CLOSE-WAIT状态可能又发送了一些数据，假设此时Seq Num = w。服务器进入LAST-ACK状态，等待客户端最后的确认。

#### 第四次挥手

客户端收到FIN报文后，发出确认报文，标志位ACK=1，Ack Num = w+1，Seq Num = u + 1. 

客户端进入TIME-WAIT状态。TCP连接并未立即释放，需要等待 2*MSL的时间，然后释放资源，进入CLOSED状态。

服务端收到确认报文后，立即进入CLOSED状态。释放资源。因此服务端结束连接的时间比客户端稍早一些。

### 常见问题

1. **为什么要挥手四次？**

   每个方向都需要一个FIN和ACK，所以需要四次。在三次握手中，服务端的确认ACK和建立连接SYN合并在一个报文。但在四次挥手中，由于客户端发送FIN仅代表不再发送数据，但是还能接收数据；服务端对FIN进行回应后，可能还有数据需要发送，需要等全部发完后才能发送FIN报文来表示服务端同意关闭连接。因此，服务器确认ACK和发送FIN需要分开发送，从而比三次握手多了一次。

2. **为什么TIME_WAIT状态等待2 * MSL 的时间？**

   MSL是报文最大生存时间，超过这个时间报文将被丢弃。如果服务端没有收到最后来自客户端的ACK报文，超时后服务端会重新发送FIN报文。客户端收到FIN后，会重新发送ACK报文给服务端。双方一去一回的时间为2*MSL。这样，客户端可以在2 * MSL 的时间内收到重传的FIN报文，然后发出ACK，重置2 * MSL的计时器。超过2 * MSL后，则说明不再有服务端重传的FIN报文，最后的ACK报文已被服务端接收，可以关闭连接了。

3. **需要TIME_WAIT状态的原因**

   - **保证连接正确关闭**

   > TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.

   RFC 793指出，TIME_WAIT的作用是等待足够的时间来确保服务端接收到最后的ACK。

   如果没有TIME_WAIT状态，当客户端最后发送的ACK报文在网络中丢失，而客户端直接进入CLOSED状态。服务端将永远无法收到最后的ACK，那么服务端则会一直处在LAST_ACK状态。

   当客户端想再次建立连接，发送SYN报文后，服务端由于一直处在LAST_ACK状态，会发送RST报文给客户端，连接建立的过程就会被终止。

   上面说过，将等待时间设置为2 * MSL可以保证服务端能够正常收到最后的ACK报文。

   - **防止新的连接收到旧连接的数据包**

   如果没有TIME_WAIT状态，当在关闭连接之前发送的数据包1在网络中延迟，然后连接正常被关闭。这时如果双方有相同端口的新的TCP连接建立，而恰好来自旧的连接的数据包1抵达，那么就有可能将这个来自旧连接的数据包接收，从而造成错乱。

   将TIME_WAIT设置成2 * MSL，保证了两个方向的数据包都已经超时丢弃，使得旧连接的数据包在网络中自然消失，从而避免了新的连接收到旧连接的数据包的情况。

4. **TIME_WAIT状态等待时间过长有什么危害**

   **内存占用**。TCP连接的资源迟迟无法释放。如果是服务器（服务器主动发起的断开请求），可能会导致线程池占满，处理不过来新的连接。

   **端口占用**。一个TCP连接至少消耗一个本地端口。当处在TIME_WAIT状态的连接过多，占满了端口，将导致无法创建新的连接。

5. **如果已经建立了连接, 但是客户端突发故障了怎么办?**

   TCP设有一个保活计时器，客户端如果出现故障，服务器不能一直等下去浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若2小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

