# HTTP 与 HTTPS

## HTTP

HTTP是超文本传输协议的缩写，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议，所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。随着发展，HTTP可以支持传输任何类型的数据。

## 特点

### 基于请求和响应

HTTP协议一般用于B/S架构，浏览器向服务端发送请求报文，服务器解析后，将数据包含在响应报文中，发送给浏览器。

### 无状态

协议对事务处理没有记忆能力，后续处理如果需要之前的信息，则必须重传。比如访问一个网站需要反复进行登录操作。对于这个特点，现有的一些解决方案比如

* 利用 Cookie / Session
* HTTP/1.1持久连接（HTTP keep-alive）。只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接

这样可以让用户在登陆后一段时间内不需要再次登陆。

### 无连接

由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。当一个用户与服务器进行频繁的请求时，建立TCP连接将耗费大量的开销。

为此，HTTP/1.1 支持了长连接，与同一个用户的多次数据传输可以使用同一个TCP信道。但对一个信道的多个请求存在排队，不支持同时处理多个HTTP连接。

HTTP/2.0在其上实现了多路复用，对于同时的多个请求，可以同时在信道上发送和接收，大幅缩短资源请求的耗时，在请求大数量资源时效果显著。

### 简单快速、灵活

客户向服务器请求服务时，只需传送请求方法和路径。HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。

## 请求报文

一个HTTP请求报文由请求行（request line）、请求头（header）、空行和请求体4个部分组成。

### 请求行

请求行由三部分组成：请求方法，请求URL（不包括域名），HTTP协议版本。

请求方法有

- **GET**：获得URI指定的资源，参数放在URL后面。传输过程中可能会被浏览器、网关等缓存，参数可以直接在地址栏看到，不适合用来传递敏感数据。一些浏览器或服务端对URL的长度有限制，不适合传递大量数据。浏览器中点击的URL都是GET请求。
- **POST**: 请求参数放在请求体中，以key1=value1&key2=value2的形式存放，不会显示在URL中。POST请求不会被缓存，可以用来传递用户信息等敏感数据。请求体没有长度限制，所以可以传递大量数据。浏览器的表单提交、文件上传等都是POST。
- **HEAD**：和GET相似，不过服务端接收到HEAD请求时只返回响应头，不发送响应体。使用HEAD不必传输整个资源内容，就可以得到资源的信息。所以，如果只需要查看某个页面的状态时，用HEAD更高效，因为省去了传输页面内容的时间。
- **PUT**: 向服务器发送请求存储一个资源，并用URI作为标识。PUT和POST都是向服务器发送数据，但PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。
- **DELETE**: 请求服务器删除URI指定的资源
- **OPTIONS**: 用于获取当前URL所支持的方法。若请求成功，会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。
- **TRACE**: 请求服务器回送收到的请求信息，主要用于测试。
- **CONNECT**: HTTP/1.1的方法，将连接转换为一个TCP/IP管道，通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。

### 请求头

- **User-Agent** : 产生请求的浏览器类型
- **Accept** : 希望接受的数据类型，比如 Accept：text/xml（application/json）
- **Accept-Encoding**: 浏览器表明自己接收的编码方法
- **Accept-Language**: 浏览器接收的语言
- **Accept-Charset**: 接收的字符集
- **Content-Length**：请求体的长度
- **Content-Type**：请求体的数据类型。比如 Content-Type：text/html（application/json）
- **Referer**：提供了该请求从哪个链接跳转而来
- **Connection**：标明Connection: keep-alive则为长连接。请求结束后，建立的TCP连接不会关闭，当客户端再次请求相同的服务器时，将继续使用这个TCP连接。有保持时间限制。
- **Host**: 请求的主机名，从URL中提取。
- **If-Modified-Since**: 检查资源的修改时间，和响应头的Last-Modified一起。当请求同一个资源时，将上一次请求返回的Last-Modified填入If-Modified-Since中。服务器将这个时间与真实资源的修改时间对比。如果未过期，则返回304, 使用缓存的文件。如果过期，则返回200, 将新的资源返回给浏览器。
- **Cache-Control**: 指定缓存机制。Public表示可以被任何缓存；Private表示只缓存到私有缓存中；no-cache表示不会被缓存。
- **Cookie**：将cookie的值发给服务器。可以用来发送session id等。

### 请求体

在浏览器发送HTTP请求时，GET请求往往通过URL来发送，这时无法设置请求体，只有URL，请求数据只能放在URL的querystring中；POST请求往往来自表单提交或发送文件，POST仍然可以在URL上附带一些参数，只不过表单里的数据都放在请求体中。

实际使用HTTP作为接口时，无论GET还是POST都可以使用请求体。我们通常把所有的“控制类”信息应该放在请求头中，具体的数据放在请求体里。于是服务器端在解析时，总是会先完全解析全部的请求头部。这样服务器端总是希望能够了解请求的控制信息后，就能决定这个请求进一步如何处理，是拒绝，还是处理数据，或者直接转发。比如，收到一个请求，检查请求头看到Content-Length里的数太大，或者Content-Type自己不支持，或者Accept要求的格式无法处理，就可以直接返回失败，节省了读取请求体的带宽。

## 响应报文

响应报文与请求报文的结构相似，也是由状态行，响应头，空行，响应体组成。

### 状态行

状态行包含了HTTP版本，状态码，以及状态码的描述。

状态码由3位十进制数字组成。详细请看[HTTP状态码](https://www.runoob.com/http/http-status-codes.html)

- 1xx（信息）：收到请求，需要继续执行操作
  - 101：Continue, 客户端继续请求
- 2xx（成功）：请求已成功接收并处理
  - 200：OK，请求成功
  - 201：Created，已创建
  - 202：Accepted, 已接受
- 3xx（重定向）：需要采取进一步措施才能完成请求
  - 301：Moved Permanently，永久重定向。浏览器会记录新的URI，以后直接跳转到新的URI。
  - 302：Found，临时重定向。以后浏览器仍然使用原有URI访问服务器，可用来流量统计等。
  - 304：Not Modified，未修改。客户端通过If-Modified-Since检查资源时，如果资源未修改，服务器返回此状态码，不会返回任何资源，客户端使用本地的缓存。
- 4xx（客户端错误）：请求包含错误的语法或无法完成请求
  - 400：Bad Request，客户端请求的语法错误，服务器无法理解
  - 401：Unauthorized，要求用户身份验证
  - 403：Forbidden，服务器理解请求，但是拒绝执行此请求
  - 404：Not-Found，服务器无法根据客户端的请求找到资源。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
  - 405：Method Not Allowed，客户端请求中的方法被禁止
- 5xx（服务器错误）：服务器在处理请求时发生错误
  - 500：Internal Server Error，服务器内部错误，无法完成请求
  - 501：Not Implemented，服务器不支持请求的功能，无法完成请求
  - 502：Bad Gateway，作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
  - 503：Service Unavailable，由于超载或系统维护，服务器暂时的无法处理客户端的请求。
  - 504：Gateway Time-out，充当网关或代理的服务器，未及时从远端服务器获取请求
  - 505：HTTP Version not supported，服务器不支持请求的HTTP协议的版本，无法完成处理

### 响应头

- **Content-Type**: 响应体的数据类型
- **Content-Length**: 响应体的长度
- **Content-Encoding**: 响应体的编码和压缩方式
- **Content-Language**: 响应体语言
- **Last-Modified**: 指定资源的最后修改时间
- **Server**: 服务器的软件信息
- **Connection**: 和请求头的Connection相同
- **Location**: 重定向的新地址
- **Date**: 生成报文的具体时间
- **Expires**: 告诉浏览器在指定过期时间内使用本地缓存
- **Set-Cookie**: 发送cookie，用来把新创建的session id返回给客户端

## 存在的问题

- 请求信息明文传输，容易被窃听截取。
- 数据的完整性未校验，容易被篡改。
- 没有验证对方身份，存在冒充危险。

## HTTPS

为了解决上述HTTP存在的问题，就用到了HTTPS。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。

### 加密

发送方随机生成密钥对消息进行对称加密。使用接收方的公钥加密对称密钥，仅有接收方可以解密，从而得到对称密钥解出明文。任何中间人无法得到接收方的私钥，也就无法破解消息。

### 数字摘要

对消息进行哈希，得到固定长度的唯一的码，不同消息的哈希码不同，将此哈希码一同发送给接收方，用于消息验证。接收方用同样的哈希函数对收到的明文进行哈希，与收到的哈希码比较，从而可以判断消息是否完整或被更改。由于哈希函数本身保证了无法从哈希码反推出明文，因此可以保证数字摘要是可靠的。

### 数字签名

验证消息是否真实来自发送方，也可以认为是验证数字摘要是否真实来自发送方。发送方用发送方的私钥对数字摘要进行加密。这样仅能用发送方的公钥进行解密，中间人无法进行伪造。

## 过程

1. 首先客户端通过URL访问服务端443端口请求建立SSL连接。包括加密协议，版本，随机数1等等
2. 服务端选择合适的加密协议，产生随机数2, 返回客户端
3. 服务端随即发送CA证书，其中包含了服务端的公钥。
4. 客户端验证证书。生成一个随机数，即预主密钥。
5. 客户端通过随机数1,随机数2,预主密钥组合成会话密钥。用服务端的公钥进行加密
6. 服务端收到后用私钥解密，同样的方式组装出会话密钥。
7. 服务端用会话密钥加密一条消息发送回客户端，用来验证是否得到了正确的会话密钥。
8. 客户端同样用会话密钥加密一条消息，用来告诉服务端消息可以正常接收。
9. SSL连接建立完成。

## 不足

### 安全性

* HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用
* SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行

### 成本

- SSL证书需要购买，功能越强大的证书费用越高
- HTTPS协议多次握手，会使页面的加载时间延长近50%，增加耗电。比较好的方式是采用分而治之，网站主页使用HTTP协议，有关于用户信息等方面使用HTTPS。
- HTTPS连接缓存不如HTTP高效，流量成本高。
- SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。