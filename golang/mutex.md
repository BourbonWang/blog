# 互斥锁 Mutex

## 互斥锁

在操作系统中，当多线程并发运行时，可能会访问或修改到共享的代码。比如下面这个例子，多个goroutine同时修改 n 的值：

```go
n := 0
add := func() {
    n = n + 1
}
for i := 0; i < 100; i++ {
    go add()
}
time.Sleep(time.Second)
fmt.Println(n)
```

最终的输出很有可能不是100. 这是因为 `n = n + 1`在底层被解释为取值、加操作、赋值的3个操作。由于上下文切换，某个线程在执行这3个操作的过程中会被中断，另一个线程开始执行，从而导致了数据不一致。

这些共享资源的代码部分称为临界区（Critical Section）。应当保证临界区内代码的原子性。操作系统中使用信号量来保护临界区。对于上面这个例子，我们可以用二元信号量来保护临界区，即互斥锁。线程得到了资源，则对资源加锁，使用结束后释放锁。资源被加锁，其他线程将无法得到该资源，直到锁被释放。这样就保证了同时仅有1个线程正在访问资源。

## Mutex

### 使用

Go 提供了 `sync.Mutex`来实现这个功能。Mutex只有两个方法：Lock() 和 Unlock()，分别代表了加锁和解锁。对于上面的例子，使用Mutex 来保护临界区：

```go
n := 0
mu := sync.Mutex{}
add := func() {
	n = n + 1
}
for i := 0; i < 100; i++ {
    mu.Lock()
    go add()
    mu.Unlock()
}
```

### 状态

查看源码，mutex的结构：

```go
type Mutex struct {
	state int32
	sema  uint32
}
```

state 是状态码，包含了4项内容：

- Locked：表示是否上锁，上锁为1 未上锁为0
- Woken：表示是否被唤醒，唤醒为1 未唤醒为0
- Starving：表示是否为饥饿模式，饥饿模式为1 非饥饿模式为0
- waiter：剩余的29位则为等待的goroutine数量

### 自旋

加锁时，如果当前Locked位为1，说明该锁当前由其他协程持有，尝试加锁的协程并不是马上转入阻塞，而是会持续的探测Locked位是否变为0，这个过程即为自旋过程。自旋时间很短（go设计为自旋4次），但如果在自旋过程中发现锁已被释放，那么协程可以立即获取锁。此时即便有协程被唤醒也无法获取锁，只能再次阻塞。

自旋的好处是，当加锁失败时不必立即转入阻塞，有一定机会获取到锁，这样可以避免协程的切换。

自旋的坏处是，如果自旋过程中获得锁，则马上执行该 goroutine。如果永远在自旋模式中，那么之前阻塞的goroutine 则很难获得锁，这样一来一些 goroutine 则会被阻塞时间过长。

### 普通模式 / 饥饿模式

go 对 mutex 的分配设计了两种模式。

在普通模式下，等待者以 FIFO 的顺序排队来获取锁，但被唤醒的等待者发现并没有获取到 mutex，并且还要与新到达的 goroutine 们竞争 mutex 的所有权。

在饥饿模式下，mutex 的所有权直接从对 mutex 执行解锁的 goroutine 传递给等待队列前面的等待者。新到达的 goroutine 们不要尝试去获取 mutex，即使它看起来是在解锁状态，也不要试图自旋。