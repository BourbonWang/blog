# Go 垃圾回收

## 内存管理

*[相关链接：GO内存管理](https://my.oschina.net/renhc/blog/2236782)*

## 垃圾回收

垃圾回收就是标记哪些内存还在使用中，也就是被引用到；哪些内存不再使用，也就是不被引用。把未被引用的内存回收，用于后续的使用。golang 会遍历所有的对象，将引用的对象标记，最终回收没有被标记的对象。

![](https://oscimg.oschina.net/oscnet/89070cc9573554666d235ddee73318a2648.jpg)

go内存的基本单元是span，span管理一个或多个内存页，并且将这些内存页分为一个个特定大小的块，这些块提供给对象使用。在span数据结构中，维护了位图allocBits，用来标记相应的块是否被分配。另一个位图 gcmarksBits，用来标记对应的块是否被引用。

在内存标记结束时，会进行回收：将allocBits 指向 gcmarkBits，这样就实现了将被引用的内存块保留，未被引用的释放。gcmarkBits则会在下次标记时重新分配位图的内存。

## 三色标记法

下面介绍标记对象所引用的内存的方法。判断一个对象是不是垃圾需不需要标记，就看是否能从当前栈或全局数据区 直接或间接的引用到这个对象。这个初始的当前goroutine的栈和全局数据区称为GC的root区。从root区开始，遍历所有对象，如果对象包含指针，则会递归的遍历指针指向的对象。将遍历过的对象标记，直到所有的对象都遍历完，这些对象就是被引用的对象。

要完成这个过程，需要3种颜色的集合，存储不同状态的对象：

- 白色：对象未被遍历，会在本次GC中清理
- 灰色：对象已被遍历，等待被标记
- 黑色：对象已被标记，不会被清理

标记的过程如下：

1. 所有的对象都在白色的集合中
2. 从root开始遍历对象，如果对象在白色集合中，就把它放到灰色集合中
3. 遍历灰色集合中的对象，检查它是否有指针指向别的对象。如果指针指向的对象也在白色集合中，即未被遍历，把它也放入到灰色集合。最后把灰色集合中检查过的对象放到黑色集合中
4. 循环步骤3，直到灰色集合中没有对象
5. 最终，白色集合中的对象就是不可达对象，也就是垃圾，进行回收

## Stop The World

标记的过程就是扫描所有对象的引用。如果，在进行标记的过程中用户修改了内存，对象的引用关系发生了改变，就可能会导致对象标记出错，最终回收了不该回收的内存。比如：A是栈上的对象，A引用了B对象. A和B都被标记为黑色。如果在完成标记后，用户将A对B的引用，更改成了A引用C。而由于C在标记时并没有被引用，所以是白色的，会被清理，这样就造成了内存错误。

所以，STW（Stop The World）就是在进行垃圾回收时，停掉所有的goroutine，待垃圾回收结束后再恢复goroutine。STW时间的长短直接影响了应用的执行。

## 写屏障 Write Barrier

