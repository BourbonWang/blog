  # goroutine

## 线程池

如果为并发的每个任务都分配一个线程，会消耗大量的资源用于创建线程，而任务完成后，这些线程又要被销毁。大量线程的并发执行会让CPU忙于上下文切换，反而会降低效率。所以，往往使用线程池来为任务分配线程。线程池中预先保存一定数量的线程，而新任务将不再以创建线程的方式去执行，而是将任务发布到任务队列，线程池中空闲的线程不断的从任务队列中取出任务并执行。这样可以有效的减少线程创建和销毁所带来的开销。

如果，某个线程执行的任务出现了阻塞（比如系统调用或者IO），这个线程只能等待阻塞完成，线程池里可用的线程就变少了，消费能力变弱了。如果是IO密集型的任务，大部分的线程都被阻塞，那么任务会堆积，而CPU并没有被很好的利用。

我们希望线程池中的线程数可以跟随消费的情况来增加和减少，并且控制得当，如果线程无节制的增加，反而会出现多个线程争抢CPU的情况。

## MPG模型

Go的线程实现模型相比于线程池，单独设计了一个调度器，用来管理任务与系统线程。

![](https://segmentfault.com/img/remote/1460000018150993?w=400&h=391)

- M 指 Machine，系统线程，由操作系统管理
- G 指 Goroutine，go 的协程，实际使用时用go关键字来创建一个协程执行任务
- P 指 Processor，P中包含了运行Go代码的必要资源，代表M的上下文，负责将G与M对接，管理等待的G。

M必须拥有P才可以执行G中的代码，P有一个包含多个G的队列，P可以调度G交由M执行。P的个数在程序启动时决定，默认情况下等同于CPU的核数，由于M必须持有一个P才可以运行Go代码，所以也意味着固定数量的M能同时运行。

上图中可见每个P维护着一个包含G的队列，不考虑G阻塞的情况下，P周期性的将G调度到M中执行，执行一小段时间，将上下文保存下来，然后将G放到队列尾部，然后从队列中重新取出一个G进行调度。

除了每个P维护的G队列以外，还有一个全局的G队列，每个P会周期性的查看全局队列中是否有G待运行并将期调度到M中执行，全局队列中G的来源，主要有从阻塞中恢复的G。之所以P会周期性的查看全局队列，也是为了防止全局队列中的G被饿死。

## 阻塞

M的数量会略大于P，类似线程池，需要时从M池中拿，用完后放回池里。这些多出来的M，可以在当一个M发生阻塞时被使用。

当一个M执行的G因为系统调用或者IO出现阻塞时，系统线程M被占用，但CPU的资源不能浪费，需要有新的M来加入运行。这时，M就会释放绑定的P，自己陷入阻塞，而P会带着队列从M池中唤醒一个空闲的M，然后继续执行下一个 G。因为P维护着上下文信息，更换M的操作很简单。只要P不空闲，就可以保证充分利用CPU。

![](https://segmentfault.com/img/remote/1460000018150995)

上图中，M0陷入了系统调用，将P释放，自己携带G0等待系统调用返回。P会另外找到一个空闲的M1，然后调度另外的G执行。

当陷入阻塞的M0返回时，会查看是否有空闲的P，如果有，将G0交给空闲的P执行；如果没有，将G0放入全局队列，然后M0返回线程池中休眠。

## 均衡

![](https://oscimg.oschina.net/oscnet/a66acebb62729fd58b34005f95c15128f90.jpg)

如果P执行完自己的G队列，全局队列也被执行完，会从其他P中的G队列偷取一半来执行。

## 总结

goroutine比其他的用户级线程开销更小。

go的GC要求内存必须在一个一致的状态，goroutine必须执行完。使用操作系统的线程调度不能很好的控制GC。go自己实现对goroutine的调度，可以自己控制在一个合适的时间进行GC。

在应用层模拟的线程，它避免了上下文切换的额外耗费，兼顾了多线程的优点。简化了高并发程序的复杂度。

