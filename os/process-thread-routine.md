# 进程和线程

## 进程

### CPU分时

单核CPU同时只能执行一个任务，如果有多个任务，CPU只能串行的执行。但是，CPU的运行速度远超其他设备，如内存、磁盘等，CPU在这些设备上的等待时间远远超过它的运行时间，CPU更希望利用这些等待的时间多做一些工作。此外，在交互式系统中，用户希望多个任务可以同时进行（或者看起来同时）。

CPU通过分时执行来解决这些问题。给每个任务分配一点时间，然后轮流来执行。当一个任务阻塞在磁盘或网络IO时，CPU可以切换到下一个任务，来提升利用率。CPU运行极快，在外面看来，仿佛是同时在执行的。但是，这种做法就要求每个任务的工作状态需要被保存，比如寄存器状态、内存等等，然后等下一次CPU临幸时加载这些工作状态。系统还需要一个管理任务执行的机制。

### 进程

于是，就有了进程。进程是操作系统的分配资源的最小单元。系统需要为每个进程分配内存空间，来保证每个任务互不侵犯，进程用逻辑地址使用这些内存。还有寄存器、网络端口等等。系统为进程分配这些资源后，这些资源由进程自己管理，操作系统只管调度。

进程一般由程序，数据和进程控制块组成。程序就是执行任务的指令集。数据包括程序运行时保存在内存里的数据。进程控制块PCB包含了进程的描述性信息和上下文信息。其中包括：

- 进程的唯一标识号PID
- 进程状态
- 寄存器
- CPU调度的相关信息：优先级，时间片，CPU核心数等
- 内存相关信息：基地址，堆栈指针等
- 分配给该进程的IO设备和打开的文件等
- 线程信息

### 创建进程

下面的事件会导致进程的创建：

- 系统初始化。系统启动时，也会启动一些守护进程。
- 用户请求创建一个新进程。比如用户点击了图标，就会创建对应的进程。
- 程序执行了创建进程的系统调用。如 fork(). 

fork()会创建一个子进程，子进程会复制当前进程的资源。已经执行完的代码作为进程状态被复制到子进程，未执行的代码会复制到子进程的代码段中，然后子进程将执行这部分。父子进程的内存通过copy-on-write共享。

### 进程的状态

![](https://s3.ax1x.com/2021/02/10/y08X9K.png)

### 进程调度

操作系统维护为各个状态都维护一个队列，队列里存放进程的PCB。当一个进程处在ready状态时，它的PCB就被放到ready队列中。当进程等待IO或事件时，它的PCB又在磁盘队列或者设备队列里。当进程被结束，PCB会被删除，资源被释放。操作系统通过维护这些队列来管理进程。当一个进程出现等待或时间片用完，操作系统需要一些算法来选择下一个执行的进程，比如轮转调度，或优先级调度等。

![](https://s3.ax1x.com/2021/02/10/y0dro4.png)

### 上下文切换

从一个进程调度到另一个进程时，系统需要先保存当前进程的上下文信息，以便在下次调度到该进程时可以恢复运行。这些信息放在PCB中，包括进程信息、寄存器、内存信息等。将CPU切换到另一个进程时，需要先将当前进程的上下文保存到PCB，然后加载下一个进程的上下文，这个过程称为上下文切换。

### 进程间通信 IPC

进程间通信主要有两种模型：共享内存和消息传递。IPC的主要方式有：

- 共享内存。是最快的可用IPC形式。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。

- 内存映射。每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间。

- 管道 pipe。管道是半双工的，数据只能单向流动，可用于父子进程之间通信。

- 命名管道 named-pipe。因为管道有名字了，可以用作没有亲缘关系的进程之间通信。

- 信号 signal。信号是在软件层次上对中断的一种模拟，用来通知进程有某一事件发生。

- 消息队列。消息队列是将消息放入链表，具有写权限的进程可以按照一定得规则向消息队列中添加新信息；有读权限得进程则可以从消息队列中读取信息。一个进程可以给若干个进程发送消息；反之,一个进程可以接收不同进程发来的消息。

  系统在内存中开辟了若干消息缓冲区。 每当一个进程向另一个进程发送消息时，便申请一个消息缓冲区，把消息送到缓冲区，然后把该缓冲区插入到接收进程的消息队列中，最后通知接收进程。接收进程收到通知后，从本进程的消息队列中摘下一消息缓冲区，取出信息，然后把消息缓冲区不定期还给系统。系统负责管理公用消息缓冲区以及消息的传递。 

- 信号量。主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。

- socket。它可用于网络中不同机器之间的进程间通信。

## 线程

有了多核处理器之后，CPU可以同时执行几个任务。进程需要将任务分割成很多个子任务，分配给CPU核心运行，于是就有了线程。一个进程可以创建多个线程，每个线程共享进程的代码段、数据段、地址空间。线程要独立运行，所以每个线程有各自的程序计数器、堆栈和寄存器。

![](https://s3.ax1x.com/2021/02/11/yBBc8J.png)

线程是CPU调度的最小单元。线程之间共享进程的上下文，所以线程的上下文切换的时间远小于进程。这样就能提高CPU利用率。可以认为，进程的任务是管理计算机分配的内存等资源，线程更注重于如何使用CPU来完成任务。

多线程与原来的进程模型（单线程）相比的优点：

- 处理迅速。比如一个web服务器可以为每个连接建立一个线程。一个执行很慢的线程并不会影响到其他的线程；而单线程模型出现这种问题会导致整个任务卡死。
- 资源共享。线程之间共享进程的内存、数据和地址空间，线程之间的资源共享和通信非常方便。
- 轻量级。创建线程和线程间切换的用时都更小。因为它们共享进程的一些资源。
- 多线程可以在多核处理器上运行，更好的利用CPU资源。

### 用户级线程

用户级线程是把整个线程放在用户空间中，内核不知道线程的存在。每个进程需要维护线程表，这些表和内核中的进程表类似，不过它仅仅记录各个线程的属性，如每个线程的程序计数器、堆栈指针、寄存器和状态。进程根据线程表调度线程。

用户级线程的优势：

- 在进行线程切换时，线程的信息会被保存在线程表中。然后，调度程序来选择另外一个需要运行的线程。保存线程的状态和调度程序都是本地过程，不需要切换到内核，也就不需要上下文切换，不需要对内存高速缓存进行刷新，因此效率比较高。
- 允许每个进程有自己定制的调度算法。
- 用户线程还具有较好的可扩展性。因为内核线程需要一些表空间和堆栈空间，如果内核线程数量比较大，容易造成问题。

用户级线程的劣势：

- 当一个线程阻塞，会导致整个进程阻塞。
- 缺页中断。实际上，计算机并不会把所有的程序都一次性的放入内存中，如果某个程序发生函数调用或者跳转指令到了一条不在内存的指令上，就会发生页面故障，而操作系统将到磁盘上取回这个丢失的指令，这就称为缺页故障。而在对所需的指令进行读入和执行时，相关的进程就会被阻塞。如果只有一个线程引起页面故障，内核由于不知道有线程存在，通常会吧整个进程阻塞直到磁盘 I/O 完成为止，尽管其他的线程是可以运行的。
- 如果一个线程开始运行，进程中的其他线程都不能运行，除非第一个线程自愿的放弃 CPU。在一个单进程内部，没有时钟中断，所以不可能使用轮转调度的方式调度线程。除非其他线程能够以自己的意愿进入运行时环境，否则调度程序没有可以调度线程的机会。

### 内核级线程

内核中会有用来记录系统中所有线程的线程表。当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，然后对线程表更新。内核中的线程表持有每个线程的寄存器、状态和其他信息。这些信息和用户空间中的线程信息相同，但是位置却被放在了内核中而不是用户空间中。另外，内核还维护了一张进程表用来跟踪系统状态。

所有能够阻塞的调用都会通过系统调用的方式来实现。当一个线程阻塞时，内核可以进行选择，是运行同一个进程中的另一个线程，还是运行另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU 时间片（或者没有可运行的线程存在了）为止。

如果某个线程造成缺页故障，内核很容易的就能检查出来是否有其他可运行的线程。如果有的话，在等待磁盘读入时，就选择一个可运行的线程运行。这样做的缺点是系统调用的代价比较大，所以如果线程的操作（创建、终止）比较多，就会带来很大的开销。

### 线程池

尽管创建一个线程肯定比创建进程更快，但是多线程服务器仍然存在潜在的问题。如果我们为所有并发请求创建一个线程，没有对系统中同时活动的线程数设置限制，可能会耗尽系统CPU和内存资源。其次，创建线程仍然需要时间，但完成任务后该线程就将被丢弃。解决该问题的一种方法是使用线程池。

线程池的总体思路是在进程启动时创建多个线程，并将它们放入一个池中。当服务器收到请求时，它会从该池中唤醒一个线程，并将服务请求传递给它。线程完成服务后，将返回到线程池中等待。如果池中没有可用的线程，服务器就会等待，直到有线程被释放回线程池。池中的线程数可以根据系统中的CPU数，内存大小以及预期的并发请求数等因素进行启发式设置。

线程池的好处：

- 使用现有线程比创建线程更快。
- 线程池限制了同时运行的线程数量，这在不能支持大量并发线程的系统上尤为重要。
- 将执行的任务与创建任务的机制分开，使我们可以用不同的策略来运行任务。例如，安排延时或定期执行。

