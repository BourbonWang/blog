# 死锁

## 发生条件

同时满足下面4种情况，系统中就可能发生死锁：

- **互斥。**对于一个资源，同时只能有一个进程访问。
- **持有并等待。**一个进程持有至少一个资源，并且在等待获取其他进程释放的资源。
- **非抢占。**资源使用后，只能由持有该资源的进程释放。资源不能被抢占。打印机就是不可抢占的资源，而内存可以被抢占。
- **循环等待。**比如进程{A,B,C}, A等待B的资源，B等待C的资源，C等待A的资源。

我们可以用资源分配图来描述资源间的关系。

点集：节点P代表进程，节点R代表资源，资源节点R中的黑点代表该资源的若干实例。

边集：P -> R 的有向边，代表进程P等待资源R；R->P的有向边，代表P持有资源R的一个实例。

![](https://s3.ax1x.com/2021/02/17/y21U1A.png)

比如，上面的资源分配图可以看出：

- P1 持有资源R2的一个实例，并且正在等待R1
- P2 持有 R1和R2，正在等待R3
- P3 持有 R3

可以看出，如果图中没有环，就不会发生死锁；反之有环，则可能发生死锁。比如下图，如果每种资源有多个实例，即使图中有环，资源也可以足够分配。

![](https://s3.ax1x.com/2021/02/17/y23P9H.png)

对于死锁，有几种处理思路：

- 破坏死锁发生的4个条件，从而防止死锁发生
- 仔细分配资源，动态的避免死锁
- 允许死锁，然后检测死锁，如果发生死锁，进行恢复
- 忽略该问题，假装死锁不会发生

下面分别介绍这几种处理方式。

## 防止死锁

破坏对锁发生的4个条件：

### 互斥

互斥是无法避免的。破坏互斥会导致同步问题。

### 持有并等待

破坏这个条件，也就是禁止已持有资源的进程再去等待其他资源。

一种实现方法是，规定所有进程在开始前请求所需的全部资源。如果全部资源可用，就分配给他；如果有资源不可用，就不进行分配，进程等待。这种做法可能会造成资源的浪费，而且很多时候进程只有在运行时才知道它需要什么资源。

### 非抢占

一种方案是，如果某个进程持有资源并且在等待别的资源，则该进程当前持有的所有资源都将被释放。这些资源将添加到该进程正在等待的资源列表中。仅当进程可以重新获得所需的全部资源时，它才会重新启动。

另一种方案是：

- 当进程请求资源时，检查资源是否可用，如果可用，就分配给该进程
- 如果不可用，检查是否有别的进程持有该资源，并且处在等待状态。如果有，抢占该资源，分配给请求进程。
- 如果资源不可用，也没有其他持有资源并且正在等待的进程，那该进程只能等待。
- 在等待时，如果其他进程请求了自己持有的资源，资源将被抢占。
- 仅当需要的资源变得可用，并且被抢占走的资源也恢复可用，进程才重新启动

这些方法适合易于保存和恢复的资源，比如寄存器和内存。

### 循环等待

对资源统一编号，规定进程必须按编号升序的顺序请求所有资源。也就是说，进程请求的资源编号，必须超过当前持有资源的最大编号。总有一个进程拥有所有已分配资源中编号最高的资源，它不能请求已分配的其他资源，因为这些资源都比它持有的最大编号低。所以资源分配图中就不会出现环。

这个方法解决了死锁，但问题是很难为大量资源设计合理的编号。

## 死锁避免

### 银行家算法

进程需要先声明它需要的每种资源的最大数量。在请求资源之前，使用银行家算法来检查这些请求是否使系统处于安全状态，如果可以，则分配资源；否则，进程必须等到其他进程释放足够的资源。

银行家算法需要定义一些数据结构：

- Allocation：已为各个进程分配的各种资源数量
- Max：每个进程所需的最大资源数量
- Need：进程还需要分配的各个资源数量，Need = Max - Allocation
- Available：系统中空闲的各资源数量

![](https://s3.ax1x.com/2021/02/17/y2Ww7V.png)

![](https://s3.ax1x.com/2021/02/17/y2WgXR.png)

### 安全状态

安全状态是指，存在一个序列{P1,P2,P3...Pn}，依次分配资源不会发生死锁。检查一个状态是否是安全状态：

- 找到一个未完成的进程Pi，它需要的资源小于系统空闲的资源：Need <= Available 
- 为它分配资源。完成后，将它已获得的资源释放回系统，Available = Available + Allocation。将该进程放入序列，代表该进程已完成。
- 寻找下一个可分配的进程。直到所有进程都可以完成，系统处于安全状态；否则，系统不在安全状态，但是，系统不安全并不代表一定发生了死锁。

以上面的图为例，首先找到P1，因为它的Need <= Available。将它放入序列，释放P1的资源，Available 变为 (5,3,2). 然后在Need矩阵中找到P3，加入序列，Available变为(7,4,3). 然后P0，P2，P4...发现都可以完成，那么系统此时是安全的。

### 请求资源

然后，当一个进程请求资源时，需要检查分配资源之后的系统是否仍是安全状态。假设一个进程请求行向量Request的资源：

- 如果Request > Need, 说明请求的资源比最开始声明的最大数量还多，系统会报错。否则

- 如果Request > Available，说明当前系统的空闲资源无法满足，进程必须等待直到系统有足够的资源。否则

- 假装为该进程分配Request的资源，更新系统状态 ：

  Available = Available – Request

  Allocation = Allocation + Request

  Need = Need – Request

- 如果分配后的系统仍是安全状态，则真正的为该进程分配资源。否则，恢复系统状态，不分配资源。

对于上图的例子，假设进程P1 请求1个A资源和2个C资源，Request = (1,0,2)。首先检查Request 小于Need 和 Available，合法。然后假装为他分配资源，系统状态变为：

![](https://s3.ax1x.com/2021/02/17/y2528O.png)

对现在的系统进行安全检查，发现有序列{P1,P3,P4,P0,P2}是安全序列，系统处在安全状态。所以可以为P1分配Request的资源，不会发生死锁。

但是银行家算法的问题是，很少有进程在开始运行之前就知道需要的资源数量，并且进程也是随时增加和减少的，这使得资源可能瞬间变得不可用。

## 检测和恢复

如果没有预防和避免死锁的措施，系统必须要有在死锁发生时检测死锁的机制，以及从死锁中恢复的方法。

### 检测

如果一个资源只有一个实例，可以维护资源分配图，然后检测图中是否有环。但是如果一个资源可以有多个实例，需要另外的死锁检测的方法。

我们可以利用银行家算法的检查安全状态的算法。增加一个Request矩阵，代表各个进程正在等待的资源请求。

- 找到一个未完成的进程Pi，它需要的资源小于系统空闲的资源：Request <= Available 
- 假装为它分配资源。完成后，将它已获得的资源释放回系统，Available = Available + Allocation。将该进程放入序列，代表该进程已完成。
- 寻找下一个可分配的进程。直到所有进程都可以完成，系统处于安全状态；否则，系统中有死锁。

![](https://s3.ax1x.com/2021/02/17/y27hfP.png)

上图中，序列{P0,P2,P3,P1,P4}是安全的，不存在死锁。

虽然在假装为进程分配资源后，该进程之后仍可能请求别的资源，然后造成死锁。但是，这种情况可以在下一次的死锁检测中发现。一般系统会定期进行死锁检测，或者在CPU利用率降至一定值后。

### 恢复

一种方法是，杀掉造成死锁的进程。

- 杀掉所有造成死锁的进程：这些进程可能运行了很久，重启后可能需要重新大量的工作。
- 一次只杀死一个进程，直到消除死锁：这使得每次杀死进程后都进行一次死锁检测，造成大量开销。而且还需要考虑如何选择要杀死的进程，有很多影响因素：优先级，已运行时间，持有的资源类型和数量，所需的资源情况等等

另一种方法是，抢占某进程的资源，分配给其他进程，直到可以消除死锁。首先需要考虑的是，如何选择被抢占的进程，可能同样有上一个方案类似的诸多影响因素。还需要避免一直抢占同一个进程，造成饥饿。另外，当进程被抢占，它需要先回到一个安全的状态，然后才能重新运行。而进程何时安全，只有它自己知道。如果对进程完全回滚，就要求系统保存进程的大量其他信息。

## 鸵鸟算法

避免死锁发生或者检查死锁耗费了大量的资源，而且不存在适合所有系统所有情况的避免死锁算法。如果死锁本身并不频繁发生，或者发生死锁造成的崩溃可以很快解决，就不需要以损失性能和可用性的代价去预防死锁。所以，最好的解决办法是像鸵鸟一样，把头埋进沙子里，假装根本没有问题发生。