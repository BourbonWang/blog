# CPU调度

## CPU调度

对于单核处理器，同时只允许一个进程进行。当进程需要等待时，CPU空闲，操作系统会将进程搁置，然后从就绪队列中选择一个进程来执行。就绪队列中存放所有等待执行的进程的PCB。

![](https://s3.ax1x.com/2021/02/10/y08X9K.png)

在以下情况会发生CPU调度：

- 当一个进程从running状态切换到waiting状态.
- 当一个进程从running状态切换到ready状态。
- 当一个进程从waiting状态切换到ready状态。
- 当一个进程 terminated 终止。

对于第1和4种情况，当前进程主动放弃了CPU控制权，叫做非抢占式调度。而2和3种情况，CPU调度时当前进程仍在执行，新进程抢占了CPU控制权，叫做抢占式调度。抢占式调度可能会对共享内存造成数据不一致的问题，需要进程间的同步措施。

## 评价指标

不同的调度算法做出了不同的权衡，适合不同的场景。有下列指标来评价CPU调度算法：

- **CPU利用率（CPU utilization）。**要使CPU尽可能的忙。
- **吞吐量（Throughput）。**指单位时间内完成进程的数量。
- **周转时间（Turnaround  time）。**从进程产生到进程完成的时间。包括等待存入内存、在就绪队列中等待、在 CPU 上执行和 IO。
- **等待时间（Waiting time）。**在就绪队列中等待所花费时间之和。CPU 调度算法并不影响进程运行和执行 I/O 的时间，它只影响进程在就绪队列中等待所花的时间。
- **响应时间（Response  time）。**对于交互系统，进程能相当早就产生输出，井继续计算新结果同时输出以前的结果给用户。周转时间通常受输出设备速度的限制。因此，响应时间是从提交请求到产生第一次响应的时间，是开始响应所需要的时间，而不是输出响应所需要的时间。

调度算法需要使CPU利用率和吞吐量最大化，而使周转时间、等待时间、响应时间最小化。为了简化问题，下面研究的都是平均等待时间。

## FCFS

先到先服务调度（First-Come First-Served）是最简单的调度算法。先出现的进程先使用CPU。FCFS可以用队列实现，每次调度选择队列头部的进程，新进程的PCB加入队列尾部。

FCFS的平均等待时间较长。考虑有下面几个进程：

```
进程  用时
P1    24
P2    3
P3    3
```

如果按P1, P2, P3的顺序到达，会得到下面的结果

![](https://s3.ax1x.com/2021/02/14/yydOVx.png)

平均等待时间为（0+24+27）/ 3 = 17。如果进程按P2, P3, P1的顺序到达，就有下面的结果

![](https://s3.ax1x.com/2021/02/14/yywpxH.png)

平均等待时间为 (0+3+6) / 3 = 3。采用 FCFS 策略的平均等待时间通常不是最小，且如果进程的CPU用时差距很大，平均等待时间也会变化很大。

FCFS会出现所有的短用时进程共同等待一个长用时的进程释放CPU的现象。与让较短进程最先执行相比，这样会导致 CPU 和设备的使用率变得更低。FCFS是非抢占的，进程会保持CPU的使用权直到主动释放CPU，在分时系统中，让一个进程长时间占有CPU是错误的。

## 轮转调度

轮转调度（Round-Robin）。相比FCFS，轮转调度是抢占式的。每次调度时，为队列中的进程分配一个很小的时间单元，称为时间片。时间片用完后，定时器会中断，然后将当前进程放入队列尾部，上下文切换到下一个进程。队列中的进程是轮流执行的，并且在固定时间内轮转。如果进程的用时小于时间片，进程在退出后就会进行调度；如果进程的用时大于时间片，当前进程就会被抢占。

和上面同样的例子：进程P1, P2, P3，如果用轮转调度，时间片为4

![](https://s3.ax1x.com/2021/02/14/yy6Y7j.png)

平均等待时间 (4+7+6) / 3 = 5.66。轮转调度的性能很大程度上依赖于时间片的大小。如果时间片非常大，就趋近于FCFS。如果时间片很小，上下文切换的次数则会增加，会占用大量的时间。

## SJF

最短作业优先调度（Shortest-Job First）选择所需时间最短的进程执行。

```
进程  用时
P1    6
P2    8
P3    7
P4    3
```

![](https://s3.ax1x.com/2021/02/14/yyc88x.png)

按所需时间最短的顺序依次执行P4,P1,P3,P2。

SJF是最短平均等待时间的算法。因为SJF将短进程移到长进程前面，短进程等待时间的减少大于长进程等待时间的增加，从而减小的平均等待时间。但是实际上，我们不知道进程需要的时间。

## 抢占式SJF

SJF可以是抢占式的。由于进程到达的顺序不同，后到达的进程可能有更短的用时。当一个新进程加入到就绪队列，根据队列中所有进程的剩余时间来进行SJF。因此也被称为最短剩余时间优先调度( shortest-remaining-time-first scheduling)。

```
进程 到达时间 剩余用时
P1     0       8
P2     1       4
P3     2       9
P4     3       5
```

- 在时间 0 时，队列中只有P1，选择P1
- 在时间 1 时，P2到达，P1的剩余时间为7，P2只需要4。P1被P2抢占
- 在时间 2 时，P3到达，剩余时间P2：3，P1：7，P3：9。继续执行P2
- 在时间 3 时，P4到达，剩余时间P2：2，P4：5，P1：7，P3：9. 继续执行P2
- 在时间 5 时，P2执行完，按剩余时间依次选择P4，P1，P3

![](https://s3.ax1x.com/2021/02/14/yycZvT.png)

平均等待时间（从到达时间开始计算）：（（10-1）+（1-1）+（17-2）+（5-3））/ 4 = 6.5 

## 优先级调度

每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到 CPU 。具有相同优先级的进程按 FCFS 顺序调度。优先级的设定可能和用时、内存要求、打开的文件数量、平均IO与平均CPU用时之比等因素有关。 SJF 算法可以看做是以剩余时间的倒数为权重的优先级调度。

优先级调度也可以是抢占式的。当有新的进程加入队列，其优先级会与当前运行的进程相比较，然后决定是否抢占。

优先级调度可能会出现饥饿 starvation。低优先级的进程可能永远不会被执行。可以通过老化 aging 来解决。逐渐增加队列里的进程的优先级，从而让低优先级的进程在一段时间后变成高优先级。

