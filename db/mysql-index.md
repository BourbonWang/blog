# MySQL 索引

索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。当对一个大表使用where子句查询一个非主键时，查询速度会很慢，因为需要遍历整个表才能查找到这个值。这时如果建立了索引，就可以像主键那样直接找到值，大幅提升查询速度。

索引分为单列索引和组合索引。

- 单列索引，即一个索引只包含单个列，一个表可以有多个单列索引。
- 组合索引，即一个索引包含多个列。

## 普通索引

最基本的索引，没有任何限制。

### 创建索引

```sql
CREATE INDEX indexName ON mytable (username(length))
```

如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。

### 修改表结构(添加索引)

```sql
ALTER table mytable ADD INDEX indexName(username(length))
```

### 创建表的时候直接指定

```sql
CREATE TABLE mytable(  
ID INT NOT NULL,   
username VARCHAR(16) NOT NULL,  
INDEX [indexName] (username(10))  
);  
```

建表时，usernname长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高INSERT的更新速度。

### 删除索引

```sql
DROP INDEX [indexName] ON mytable; 
```

## 唯一索引

它与前面的普通索引类似，区别是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

### 创建索引

```sql
CREATE UNIQUE INDEX indexName ON mytable(username(length)) 
```

### 修改表结构

```sql
ALTER table mytable ADD UNIQUE [indexName] (username(length))
```

### 创建表的时候直接指定

```sql
CREATE TABLE mytable(  
ID INT NOT NULL,   
username VARCHAR(16) NOT NULL,  
UNIQUE [indexName] (username(length))  
);
```

## 主键索引

主键索引也是特殊的唯一索引。主键在物理层面上只有两个用途：

- 惟一地标识一行。
- 作为一个可以被外键有效引用的对象。

主键一定是唯一性索引，但主键并不允许有空值。一个表只能有一个主键，但可以有多个唯一索引。

主键是逻辑键，而索引是物理键。一般在建表的时候指定主键，同时在物理层面创建主键索引。

```sql
CREATE TABLE mytable(
ID INT NOT NULL, 
username VARCHAR(16) NOT NULL,
PRIMARY KEY(ID) 
);
```

与之类似的，也有外键索引。如果为某个外键字段定义了一个外键约束条件，MySQL就会定义一个内部索引来帮助自己以最有效率的方式去管理和使用外键约束条件。

## 组合索引

类比于主键可以包含多个列，索引也可以包含多个列。这样的索引称为组合索引。

```sql
CREATE TABLE mytable( 
    ID INT NOT NULL, 
    username VARCHAR(16) NOT NULL, 
    city VARCHAR(50) NOT NULL, 
    age INT NOT NULL 
);
```

比如，在上面的表中建立一个组合索引：

```sql
ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);
```

建立这样的组合索引，其实是相当于分别建立了三组组合索引：`(usernname,city,age)`，`(usernname,city)`，`(usernname)`。

为什么没有 `(city,age)`这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合, 并不是只要包含这三列的查询都会用到该组合索引。下面的几个SQL就会用到这个组合索引：

```sql
SELECT * FROM mytable WHERE username="admin" AND city="郑州"
SELECT * FROM mytable WHERE username="admin"
```

而下面的则不会用到：

```sql
SELECT * FROM mytable WHERE age=20 AND city="郑州"
SELECT * FROM mytable WHERE city="郑州"
```

组合索引更像是依次检索username -> city -> age，逐层的确定出一行。因为组合索引在底层存储中保证了依次有序，非常适合上面这类查询。

## 全文索引

对于查询文本中的关键词，可以建立全文索引。但InnoDB内部并不支持中文、日文等，因为这些语言没有分隔符。可以使用插件辅助实现中文、日文等的全文索引。与使用`like '%word%'`相比，全文索引效率更高。

```SQL
CREATE FULLTEXT INDEX indexName ON mytable(column);
select * from mytable where match(column) against('word');
```

match() 函数中指定的列必须和全文索引中指定的列完全相同，否则就会报错，这是因为全文索引不会记录关键字来自哪一列。如果想要对某一列使用全文索引，请单独为该列创建全文索引。此外，innodb的全文索引只会对长度大于3小于84的词建立索引。

## 注意事项

### 设计

- **索引字段尽量使用数字型（简单的数据类型）**。在处理查询时，字符串类型会逐个比较每个字符，而对于数字类型只需要比较一次。

- **尽量不要让字段的默认值为NULL**。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。在设计时，应该用0、一个特殊的值或者一个空串来代替NULL。

- **使用前缀索引并且保证较高的索引选择性。**对字符串或文本进行索引，应该指定索引的前缀长度。目的是用较短的存储空间就可以索引出更多的值。

  比如，用一个CHAR(255)的列来存储用户名，通常在前20个字符内就可以把搜索范围缩小到几条数据，这样建立一个短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作；而如果CHAR(255)的列在前10-20个字符内多数值是相同的，那就不要对整个列进行索引。

  关键在于，要选择足够长的前缀来保证较高的索引选择性，同时又不能太长。索引选择性是指不重复的索引值和数据表中的记录总数的比值。索引的选择性越高，查找时就可以过滤掉更多的行。唯一索引的选择性是1. 

- **使用唯一索引**。上一点说到，唯一索引的选择性最高，索引的效果最好。

- **使用组合索引代替多个列索引。**

- **注意重复和不使用的索引**。MySQL允许在相同的列上创建多个索引，无论是有意还是无意的。大多数情况下不需要使用冗余索引。对于重复和不使用的索引：可以直接删除这些索引。因为这些索引需要占用物理空间，并且也会影响更新表的性能。

### 使用

- **如果要对文本进行搜索，使用全文索引**，而不是like 

- **like不要以通配符开头**。以通配符%和_ 开头作为查询时，MySQL不会使用索引。

- **不要在列上进行运算，也不要做函数参数**。比如下面两个查询都无法使用索引：

  ```SQL
  select actor_id from sakila.actor where actor_id+1=5;
  select ... where TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col)<=10;
  ```

- **尽量不要使用NOT IN, <>, != 操作**。可以将NOT IN用NOT EXISTS代替，将`a<>0`用`a<0 or a >0`代替

- **尽量避免在 where 子句中使用 or 来连接条件**。用 or 分割开的条件， 如果 or 前的条件中的列有索引， 而后面的列中没有索引， 那么涉及到的索引都不会被用到。

- **组合索引的使用要遵守“最左前缀”原则**。对于一个组合索引(a,b,c)：查询必须从索引左边的列开始，比如查询（a,b）。不能跳过某一列，比如查询(a,c)是不行的。不能使用索引中范围条件右边的列，比如`WHERE a=123 AND b LIKE 'cde%' AND c='sdgf' `只能使用(a,b)的索引，因为LIKE是范围查询。

- 如果列类型是字符串，那么一定记得在 where 条件中把字符常量值用引号 ' ' 引起来。否则的话即便这个列上有索引，MySQL 也不会用到的，因为MySQL 默认把输入的常量值进行转换以后才进行检索。

- 

## 索引的存储类型

### B-树

传统用来搜索的平衡二叉树有很多，如 AVL 树，红黑树等。这些树在一般情况下查询性能非常好，但当数据非常大的时候它们就无能为力了。原因当数据量非常大时，大部分数据只能存放在磁盘上，只有需要的数据才加载到内存中。磁盘读取时间远远超过了数据在内存中比较的时间，这时程序大部分时间会阻塞在磁盘 IO 上。我们需要尽可能的减少磁盘 IO 次数来提升性能。

平衡二叉树是通过旋转来保持平衡的，而旋转是对整棵树的操作，若部分加载到内存中则无法完成旋转操作。其次平衡二叉树的高度相对较大为 log n（底数为2），这样逻辑上很近的节点实际可能非常远，无法很好的利用磁盘预读（局部性原理），因此像AVL树，红黑树这类平衡二叉树从设计上无法迎合磁盘。

> 空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。

B-树是专门为外部存储器设计的，如磁盘，它对于读取和写入大块数据有良好的性能，所以一般被用在文件系统及数据库中。B-树也是平衡树，相比与平衡二叉树，B-树允许每个节点有更多的子节点。它有以下特点：

- 所有键值分布在整颗树中（索引值和具体data都在每个节点里）；
- 任何一个关键字出现且只出现在一个结点中；
- 搜索有可能在非叶子结点结束，最好情况O(1)就能找到数据；
- 在关键字全集内做一次查找, 性能逼近二分查找；

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDQ2MDg3LWJjMDIzZTQ3YmM3NGNmYTEuanBn?x-oss-process=image/format,png)

B-树将整个表范围分割为多个区间，区间越多，定位数据越快越精确，节点也越大。新建节点时，直接申请页大小的空间（磁盘存储单位是按 block 分的，一般为 512 Byte。磁盘一次读取若干个 block 称为一页，具体大小和操作系统有关），计算机内存分配是按页对齐的，这样一个节点只需要一次磁盘 IO。

### B+树

MySQL的innodb采用B+树作为底层数据结构。B+树是B-树的变体，也是一种多路搜索树, 它与 B-树的不同之处在于:

- 所有data存储在叶子节点，非叶子节点并不存储真正的 data
- 为所有叶子结点增加了一个指针，指向下一个叶子节点

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNDQ2MDg3LTMwYjcwYWFhMjg0MDM4MDMuanBn?x-oss-process=image/format,png)

B+树的内节点并不存储data，所以一般B+树的叶子节点和内部节点大小不同，而B树的每个节点大小是相同的，为一页。另外，B+树查询的时间复杂度固定为log n（底为分叉数），而B树的查询时间复杂度与key在树的位置有关。

B+树可以很好的利用空间局部性原理。由于B+树的叶子节点的数据都是使用链表连接起来的，而且他们在磁盘里是顺序存储的，所以当读到某个值的时候，磁盘预读原理就会提前把这些数据都读进内存，使得范围查询和排序都很快。在范围查询时，比如查询500-1000之间的节点，利用磁盘预读原理可以减少磁盘IO次数。

由于B+树的内部节点只存储索引的副本和指针，不存储data，所以在同样都是读取一页的IO中，B+树能读取到的索引值多于B树。从而减少了查询需要的IO次数。

使用B+树作为索引能让数据库的查询速度上升，而使写入数据的速度下降。因为平衡树这个结构必须一直维持在一个正确的状态，增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构。因此，在每次改变数据时，DBMS必须去重新梳理树的结构以确保它的正确，这会带来不小的性能开销，这也是索引会给查询以外的操作带来副作用的原因。

### 索引查询

B+树可以对<，<=，=，>，>=，BETWEEN，IN，以及不以通配符开始的LIKE使用索引。

![](https://pic3.zhimg.com/80/v2-a0669007f11ae9e57bd64394295f84aa_720w.jpg)

B+树可以进行以下查询：

- 匹配全值：对索引中的所有列都指定具体的值。例如，上图中索引可以帮助你查找出生于1960-01-01的Cuba Allen。
- 匹配最左前缀：你可以利用索引查找last name为Allen的人，仅仅使用索引中的第1列。根据最左前缀原则，查询必须从最左边的列开始，并且不能跳过某一索引列。比如，不能直接查询first name，也不能查询(last  name, date)
- 匹配列前缀：例如，你可以利用索引查找last name以J开始的人，这仅仅使用索引中的第1列。
- 匹配值的范围查询：可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。
- 匹配部分精确而其它部分进行范围匹配：可以利用索引查找last name为Allen，而first name以字母K开始的人。但使用范围条件后，它后面的列将无法使用索引。
- 仅对索引进行查询：如果查询的列都位于索引中，则不需要再多一次I/O回读元组。索引的叶子节点中已经包含要查询的数据，那么就没有必要再回表查询了，如果索引包含满足查询的所有数据，就称为覆盖索引。比如，`select date from people where last_name='Allen' and first_name='Cuda'; `所需要的date 已经包含在了索引中，所以不需要再从真正的数据节点里读取了。

### 聚簇索引

当建表时，我们给表加上了主键，这时表在磁盘上的存储结构变成了B+树，整个表的索引就是主键。这就是聚簇索引。一个表只能有一个主键，一个表也只能有一个聚簇索引，因为主键的作用就是把表的存储格式转换成树状的索引。如果不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后建立聚簇索引。

一个表只能有一个聚簇索引，用来存储数据。但一个表可以有多个索引，显然不能为每个索引树都复制一份数据，于是就有了非聚簇索引（二级索引）。和聚簇索引一样，非聚簇索引也用B+树作为存储结构，也用索引列的字段作为节点值。不同的是，非聚簇索引的叶子节点存放的是数据行的主键，而不是数据行本身。

每次给表新建一个索引时，索引列中的值都会被复制出来一份，用于生成新的非聚簇索引。增删改数据时，这些的索引树也都会更新。因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。

在查询非主键索引时，数据库会先通过对应的非聚簇索引找到对应数据的主键值，然后用主键去查询聚集索引，得到数据。一共进行了2次B+树查询。

![](https://images2015.cnblogs.com/blog/303980/201703/303980-20170331184024758-1937607304.jpg)

无论以任何方式查询，最终都会用主键通过聚簇索引来定位到数据，聚簇索引（主键）是通往真实数据所在的唯一路径。

然而还有另外一种特殊的方法可以不使用聚簇索引就能得到数据，即覆盖索引。建立一个索引时，索引列的数据会复制一份到索引树中。如果建立的是组合索引，树的节点中就会有多个列值。比如我们建立一个组合索引 (name, age)，树中的节点也应当包含这两个字段的值。按最左前缀原则，我们可以只对name进行查询。当查询`select age from mytable where name='xxx';`时，如果在索引树中通过name定位到了唯一的索引项，而我们所需要的age字段也在索引项里，那么我们就可以直接返回索引项中的age字段，而不需要再获取主键、再查聚簇索引。通过这种覆盖索引直接查找的方式，可以省略覆盖索引查找的后面两个步骤，大大的提高了查询性能。

### 哈希索引

MySQL中，只有Memory存储引擎显示支持hash索引。哈希索引基于哈希表实现，只有精确索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据的指针。

Hash索引有以下一些限制：

- 由于索引仅包含哈希码和记录指针，所以，MySQL不能通过使用索引避免读取记录，即每次使用哈希索引查询到记录指针后都要回读元组查取数据。
- 不能使用hash索引排序。
- Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。
- Hash索引只支持等值比较，例如使用=，IN( )和<=>。对于WHERE price>100并不能加速查询。
- 访问Hash索引的速度非常快，除非有很多哈希冲突（不同的索引列值却有相同的哈希值）。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。
- 如果哈希冲突很多的话，一些索引维护操作的代价也会很高。当从表中删除一行时，存储引擎要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。

InnoDB引擎有一个特殊的功能叫做自适应哈希索引。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于缓冲池中的B+树索引上再创建一个哈希索引，这样就使B+树索引也具有哈希索引的一些优点，比如快速的哈希查找。启用自适应哈希索引后，读和写性能可以提高2倍，对于辅助索引的连接操作，性能可以提高5倍。

## 索引的优点

- 索引大大减小了服务器需要扫描的数据量
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机IO变成顺序IO
- 索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询时锁更少的元组。在MySQL5.1和更新的版本中，InnoDB可以在服务器端过滤掉行后就释放锁。但在早期的MySQL版本中，InnoDB直到事务提交时才会解锁。对不需要的元组的加锁，会增加锁的开销，降低并发性。而索引能够减少InnoDB访问的元组数。InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）。

## 索引的缺点

- 虽然索引大大提高了查询速度，同时却会降低增删改的速度。因为MySQL不仅要修改数据，还要修改索引文件。
- 建立索引会增加索引文件占用的磁盘空间。如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。MySQL里同一个数据表里的索引总数限制为16个。
- 如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
- 对于非常小的表，大部分情况下简单的全表扫描更高效；

