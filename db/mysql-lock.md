# MySQL 乐观锁与悲观锁

乐观锁和悲观锁是两种常见的资源并发锁设计思路，不是MySQL提供的锁机制。

## 悲观锁

悲观锁就是对并发处理持悲观态度，总认为会发生并发冲突。进行每次操作时都要先对数据锁定，然后才能操作数据。 

数据库层面的悲观锁已经通过共享锁和排它锁提供，使用时可以直接调用。在使用之前，需要关闭MySQL的自动提交 `set autocommit=0`

### 共享锁

共享锁允许多个事务查询同一数据，但会阻止其他事务获取相同数据的排它锁，即阻止其他事务修改数据。类似于读写锁中的读锁。

使用时，通过在sql语句后加上`lock in share mode`来对资源加共享锁。

```SQL
select * from table_name where .....lock in share mode
```

 对资源加上共享锁，会阻塞其他事务修改该资源，也会阻塞其他未声明`lock in share mode`的查询事务。

### 排它锁

排它锁要求多个事务对同一资源只能有一把锁，即阻止其他资源获得共享锁和排它锁。类似于读写锁中的写锁。

使用时，通过在sql语句后加上`for update`来对资源加排他锁。

```SQL
select * from table_name where .....for update
```

使用排它锁会把数据给锁住，不过需要注意一些锁的级别。InnoDB默认使用行级锁，但是只有明确地指定索引，MySQL 才会执行行级锁；否则MySQL 将会执行表级锁。

### 总结

- 悲观锁适用于可靠的持续性连接，诸如C/S应用。 对于Web应用的HTTP连接，先天不适用
- 锁的使用意味着性能的损耗，在高并发、锁定持续时间长的情况下，尤其严重。 Web应用的性能瓶颈多在数据库处，使用悲观锁，进一步收紧了瓶颈
- 非正常中止情况下的解锁机制，设计和实现起来很麻烦，成本还很高
- 不够严谨的设计下，可能产生不易被发现的， 的死锁问题

## 乐观锁

对数据并发持乐观态度，认为数据一般不会发生冲突，只有在提交更新时，才会对冲突进行检查。

数据库本身不提供乐观锁，需要自己在业务上实现。一般实现方式是：在表中增加一列版本号，或时间戳，用来唯一标识当前数据的版本。读取数据时，将版本号一同读出；每次更新时，将版本号加1（或更新时间戳）。在提交更新时，再次读出版本号，判断当前的版本号与第一次的版本号是否相等。如果相等，说明数据没有被其他事务更改，可以更新；不相等，说明数据已经过期，则拒绝更新。

![](https://images2017.cnblogs.com/blog/1220001/201709/1220001-20170906152042569-23894159.jpg)

如上图所示，如果更新操作顺序执行，则数据的版本依次递增，不会产生冲突。但是如果发生有不同的业务操作对同一版本的数据进行修改，那么，先提交的事务B会把数据版本更新为2，当A在B之后提交更新时发现数据的版本已经被修改了，那么A的更新操作会失败。

### 总结

- 乐观锁是基于程序实现的，所以不存在死锁的情况，适用于读多的应用场景。
- 乐观锁机制避免了长事务中的数据库加锁开销，大大提升了大并发量下的系统整体性能表现。
- 如果经常发生冲突，上层应用不断的让用户进行重新操作，这反而降低了性能，这种情况下悲观锁就比较适用。
- 乐观锁机制往往基于业务系统中的数据存储逻辑，来自外部的更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。可以将乐观锁在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途径，而不是将数据库表直接对外公开。

